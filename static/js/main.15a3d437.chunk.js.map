{"version":3,"sources":["libs/board.js","libs/animate.js","libs/algorithms/bfs.js","libs/algorithms/dfs.js","libs/algorithms/bi-swarm.js","stores/store.js","components/Cell.js","components/Graph.js","libs/maze.js","components/Header.js","serviceWorker.js","index.js"],"names":["clearBoard","keepWalls","sourceNode","targetNode","visitedNodes","grid","source","target","Object","keys","forEach","node","toString","animate","timeoutOffset","nodeId","nodeToParent","animationProperties","setTimeout","shortestPathTimeoutOffset","shortestPath","push","parentId","pop","nodeClass","replace","length","runBFS","networkMap","enableAnimation","queue","Set","nodesToVisit","shift","setHashKey","add","i","neighbor","has","runDFS","stack","runBiSwarm","sourceNodeId","targetNodeId","sourceVisitedNodes","targetVisitedNodes","sourceQueue","targetQueue","sourceNodeToParent","targetNodeToParent","sourceNodesToVisit","targetNodesToVisit","searchForTarget","dequeueNode","sourceSetHashKey","getNodeSetHashKey","destinationNode","sourceParentId","sourceNeighbor","isNodeUndiscovered","nodeSetHashKey","CellStore","classType","selectedNode","visitedTargetNodes","animationQueue","row","col","activeAlgorithm","getGrid","randomNumber","min","max","Math","floor","random","getRandomInt","runVisualizer","decorate","observable","CellStoreContext","createContext","Cell","observer","props","cellStore","useContext","useState","id","setClassType","newClassType","draggable","className","onMouseDown","onMouseOver","onMouseUp","Graph","network","j","key","createNetworkMap","cellSpacing","align","onMouseLeave","rowsInGrid","map","cellsInRow","cellId","createGrid","generateMaze","addOuterWalls","addInnerWalls","h","minX","maxX","minY","maxY","y","hole","addHWall","x","addVWall","animateMaze","Header","title","setTitle","visualizeTitle","setVisualizeTitle","Navbar","bg","expand","Brand","style","margin","Toggle","aria-controls","Collapse","Nav","NavDropdown","Item","onClick","Link","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","innerHeight","innerWidth","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.15a3d437.chunk.js","sourcesContent":["export function clearBoard(keepWalls, sourceNode, targetNode, visitedNodes, grid) {\r\n    let source = sourceNode;\r\n    let target = targetNode;\r\n    Object.keys(grid).forEach((node) => {\r\n        if (node.toString() === source.toString()){\r\n            grid[node] = 'startCell';\r\n        } else if (node.toString() === target.toString()) {\r\n            grid[node] = 'targetCell';\r\n        } else if(node.toString() !== source.toString() && node.toString() !== target.toString()) {\r\n            if(!keepWalls) {\r\n                grid[node] = 'defaultCell';\r\n            } else if (grid[node] !== 'wallCell') {\r\n                grid[node] = 'defaultCell';\r\n            }\r\n        } \r\n    })\r\n}","export function animate(timeoutOffset, nodeId, source, target, nodeToParent, grid, animationProperties) {\r\n        \r\n    setTimeout(() => {\r\n        if(nodeId !== source && !(nodeId[0] === target[0] && nodeId[1] === target[1])){\r\n            grid[nodeId] = \"discoveredCell\";\r\n        } else if (nodeId[0] === target[0] && nodeId[1] === target[1]) {\r\n            let shortestPathTimeoutOffset = 0;\r\n            let shortestPath = [];\r\n            shortestPath.push(nodeId);\r\n            while (nodeId != null){\r\n                let parentId = nodeToParent[nodeId];\r\n                if (parentId) {\r\n                    shortestPath.push(parentId);\r\n                }\r\n                nodeId = parentId;\r\n            }\r\n            \r\n            while (shortestPath.length > 0){\r\n                shortestPathTimeoutOffset+=35;\r\n                let nodeId = []\r\n                nodeId = shortestPath.pop();\r\n                let nodeClass = \"\";\r\n                if (nodeId.toString() === source.toString() || nodeId.toString() === target.toString()) {\r\n                    nodeClass = \"shortestPath \" + grid[nodeId].replace('discoveredCell','');\r\n                } else {\r\n                    nodeClass = \"shortestPath\";\r\n                }\r\n                setTimeout(() => {  \r\n                    grid[nodeId] = nodeClass;\r\n                }, shortestPathTimeoutOffset);\r\n            }\r\n\r\n            setTimeout(() => {  \r\n                animationProperties['isAnimationInProgress'] = false;\r\n            }, shortestPathTimeoutOffset);\r\n        } else {\r\n            grid[nodeId] += \" discoveredCell\";\r\n        }\r\n    }, timeoutOffset);\r\n}","import { clearBoard } from '../board.js'\r\nimport { animate } from '../animate.js'\r\n\r\nexport function runBFS(networkMap, sourceNode, targetNode, visitedNodes, grid, enableAnimation, animationProperties){\r\n    let source = sourceNode;\r\n    let target = targetNode;\r\n\r\n    clearBoard(true, sourceNode, targetNode, visitedNodes, grid);\r\n\r\n    let queue = [];\r\n    let nodeToParent = {};\r\n    visitedNodes = new Set();\r\n    let nodesToVisit = new Set();\r\n    let timeoutOffset = 0;\r\n    queue.push({\r\n        'parentId': null,\r\n        'nodeId': source\r\n    });\r\n    \r\n    while(queue.length > 0) {\r\n        let node = queue.shift();\r\n        let nodeId = node['nodeId'];\r\n        let parentId = node['parentId'];\r\n\r\n        nodeToParent[nodeId] = parentId;\r\n\r\n        let setHashKey = nodeId[0] + \"-\" + nodeId[1];\r\n        timeoutOffset+=15;\r\n        \r\n        visitedNodes.add(setHashKey);\r\n        if (!enableAnimation){\r\n            if(nodeId !== source && !(nodeId[0] === target[0] && nodeId[1] === target[1])){\r\n                grid[nodeId] = \"discoveredCellNoAnimate\";\r\n            } else if (nodeId[0] === target[0] && nodeId[1] === target[1]) {\r\n            }\r\n        } else {\r\n            animate(timeoutOffset, nodeId, source, target, nodeToParent, grid, animationProperties);\r\n        }\r\n        \r\n        if (nodeId[0] === target[0] && nodeId[1] === target[1]) {\r\n            if (!enableAnimation) {\r\n                while (nodeId != null){\r\n                    grid[nodeId] = \"shortestPathNoAnimate \" + grid[nodeId].replace('discoveredCell','').replace('defaultCell','');\r\n                    let parentId = nodeToParent[nodeId];\r\n                    if (parentId) {\r\n                        grid[parentId] = \"shortestPathNoAnimate \" + grid[parentId].replace('discoveredCell','');\r\n                    }\r\n                    nodeId = parentId;\r\n                }\r\n            }\r\n\r\n            break;\r\n        } else {\r\n            for (let i=0; i < networkMap[nodeId].length; i++) {\r\n                let neighbor = networkMap[nodeId][i];\r\n                setHashKey = neighbor[0] + \"-\" + neighbor[1];\r\n                if (!visitedNodes.has(setHashKey) && !nodesToVisit.has(setHashKey) && grid[neighbor] !== 'wallCell') {\r\n                    nodesToVisit.add(setHashKey);\r\n                    queue.push({\r\n                        'parentId': nodeId,\r\n                        'nodeId': neighbor\r\n                    });\r\n            \r\n                }\r\n            }\r\n        }\r\n    }\r\n    return visitedNodes;\r\n}","\r\nimport { clearBoard } from '../board.js'\r\nimport { animate } from '../animate.js'\r\n\r\nexport function runDFS(networkMap, sourceNode, targetNode, visitedNodes, grid, enableAnimation, animationProperties) {\r\n    let source = sourceNode;\r\n    let target = targetNode;\r\n    \r\n    clearBoard(true, sourceNode, targetNode, visitedNodes, grid);\r\n    \r\n    let stack = [];\r\n    let nodeToParent = {};\r\n    visitedNodes = new Set();\r\n    let nodesToVisit = new Set();\r\n    let timeoutOffset = 0;\r\n    stack.push({\r\n        'parentId': null,\r\n        'nodeId': source\r\n    });\r\n    while(stack.length > 0) {\r\n        let node = stack.pop();\r\n        let nodeId = node['nodeId'];\r\n        let parentId = node['parentId'];\r\n    \r\n        nodeToParent[nodeId] = parentId;\r\n    \r\n        let setHashKey = nodeId[0] + \"-\" + nodeId[1];\r\n        timeoutOffset+=15;\r\n        \r\n        visitedNodes.add(setHashKey);\r\n        if (!enableAnimation){\r\n            if(nodeId !== source && !(nodeId[0] === target[0] && nodeId[1] === target[1])){\r\n                grid[nodeId] = \"discoveredCellNoAnimate\";\r\n            } else if (nodeId[0] === target[0] && nodeId[1] === target[1]) {\r\n            }\r\n        } else {\r\n            animate(timeoutOffset, nodeId, source, target, nodeToParent, grid, animationProperties);\r\n        }\r\n        \r\n        if (nodeId[0] === target[0] && nodeId[1] === target[1]) {\r\n            if (!enableAnimation) {\r\n                while (nodeId != null){\r\n                    let parentId = nodeToParent[nodeId];\r\n                    if (parentId && parentId.toString() !== source.toString()) {\r\n                        grid[parentId] = \"shortestPathNoAnimate\";\r\n                    }\r\n                    nodeId = parentId;\r\n                }\r\n    \r\n            }\r\n    \r\n            break;\r\n        } else {\r\n            for (let i=0; i < networkMap[nodeId].length; i++) {\r\n                let neighbor = networkMap[nodeId][i];\r\n                setHashKey = neighbor[0] + \"-\" + neighbor[1];\r\n                if (!visitedNodes.has(setHashKey) && !nodesToVisit.has(setHashKey) && grid[neighbor] !== 'wallCell') {\r\n                    stack.push({\r\n                        'parentId': nodeId,\r\n                        'nodeId': neighbor\r\n                    });\r\n            \r\n                }\r\n            }\r\n        }\r\n    }\r\n    return visitedNodes;\r\n}\r\n\r\n","import { clearBoard } from '../board.js'\r\nimport { animate } from '../animate.js'\r\n\r\nexport function runBiSwarm(networkMap, sourceNodeId, targetNodeId, sourceVisitedNodes, targetVisitedNodes, grid, enableAnimation, animationProperties){\r\n    clearBoard(true, sourceNodeId, targetNodeId, sourceVisitedNodes, grid);\r\n\r\n    let sourceQueue = [];\r\n    let targetQueue = [];\r\n    let sourceNodeToParent = {};\r\n    let targetNodeToParent = {};\r\n    sourceVisitedNodes = new Set();\r\n    targetVisitedNodes = new Set();\r\n    let sourceNodesToVisit = new Set();\r\n    let targetNodesToVisit = new Set();\r\n    let timeoutOffset = 0;\r\n    sourceQueue.push({\r\n        'parentId': null,\r\n        'nodeId': sourceNodeId\r\n    });\r\n    targetQueue.push({\r\n        'parentId': null,\r\n        'nodeId': targetNodeId\r\n    });\r\n    \r\n    while(sourceQueue.length > 0 && targetQueue.length > 0 ) {\r\n        timeoutOffset+=15;\r\n\r\n        if (sourceQueue.length > 0) {\r\n            sourceQueue = searchForTarget(sourceQueue, sourceNodeToParent, sourceVisitedNodes, sourceNodesToVisit, targetNodeToParent, targetVisitedNodes, enableAnimation, sourceNodeId, targetNodeId, grid, timeoutOffset, networkMap, animationProperties)\r\n        }\r\n        if (targetQueue.length > 0) {\r\n            targetQueue = searchForTarget(targetQueue, targetNodeToParent, targetVisitedNodes, targetNodesToVisit, sourceNodeToParent, sourceVisitedNodes, enableAnimation, targetNodeId, sourceNodeId, grid, timeoutOffset, networkMap, animationProperties)\r\n        }\r\n    }\r\n    return sourceVisitedNodes;\r\n}\r\n\r\nfunction searchForTarget(sourceQueue, sourceNodeToParent, sourceVisitedNodes, sourceNodesToVisit, targetNodeToParent, targetVisitedNodes, enableAnimation, sourceNodeId, targetNodeId, grid, timeoutOffset, networkMap, animationProperties) {\r\n    let [nodeId, parentId] = dequeueNode(sourceQueue);\r\n    sourceNodeToParent[nodeId] = parentId;\r\n\r\n    let sourceSetHashKey = getNodeSetHashKey(nodeId);\r\n    sourceVisitedNodes.add(sourceSetHashKey);\r\n\r\n\r\n    if (!enableAnimation){\r\n        if(nodeId !== sourceNodeId && !targetVisitedNodes.has(sourceSetHashKey)){\r\n            grid[nodeId] = \"discoveredCellNoAnimate\";\r\n        }\r\n    } else {\r\n        animate(timeoutOffset, nodeId, sourceNodeId, targetNodeId, sourceNodeToParent, grid, animationProperties);\r\n    }\r\n    \r\n    if (targetVisitedNodes.has(sourceSetHashKey)) {\r\n        let destinationNode = nodeId;\r\n        if (!enableAnimation) {\r\n            while (nodeId != null){\r\n                grid[nodeId] = \"shortestPathNoAnimate \" + grid[nodeId].replace('discoveredCell','').replace('defaultCell','');\r\n                let sourceParentId = sourceNodeToParent[nodeId];\r\n                if (sourceParentId) {\r\n                    grid[sourceParentId] = \"shortestPathNoAnimate \" + grid[sourceParentId].replace('discoveredCell','');\r\n                }\r\n                nodeId = sourceParentId;\r\n            }\r\n            grid[destinationNode] = \"shortestPathNoAnimate\";\r\n            while (destinationNode != null){\r\n                grid[destinationNode] = \"shortestPathNoAnimate \" + grid[destinationNode].replace('discoveredCell','').replace('defaultCell','');\r\n                let sourceParentId = targetNodeToParent[destinationNode];\r\n                if (sourceParentId && sourceParentId.toString() !== targetNodeId.toString()) {\r\n                    grid[sourceParentId] = \"shortestPathNoAnimate \" + grid[sourceParentId].replace('discoveredCell','');\r\n                }\r\n                destinationNode = sourceParentId;\r\n            }\r\n        } else {\r\n            animate(timeoutOffset, nodeId, sourceNodeId, nodeId, sourceNodeToParent, grid, animationProperties);\r\n            animate(timeoutOffset, nodeId, targetNodeId, nodeId, targetNodeToParent, grid, animationProperties);\r\n        }\r\n        sourceQueue = [];\r\n        return [];\r\n        \r\n    } else {\r\n        for (let i=0; i < networkMap[nodeId].length; i++) {\r\n            let sourceNeighbor = networkMap[nodeId][i];\r\n            sourceSetHashKey = getNodeSetHashKey(sourceNeighbor);\r\n            if (isNodeUndiscovered(sourceNeighbor, sourceSetHashKey, sourceVisitedNodes, sourceNodesToVisit, targetVisitedNodes, grid)) {\r\n                sourceNodesToVisit.add(sourceSetHashKey);\r\n                sourceQueue.push({\r\n                    'parentId': nodeId,\r\n                    'nodeId': sourceNeighbor\r\n                });\r\n            }\r\n        }\r\n    }\r\n    return sourceQueue;\r\n}\r\n\r\nfunction getNodeSetHashKey(nodeId){\r\n    return nodeId[0] + \"-\" + nodeId[1];\r\n}\r\n\r\nfunction isNodeUndiscovered(node, nodeSetHashKey, sourceVisitedNodes, sourceNodesToVisit, targetVisitedNodes, grid){\r\n    return !sourceVisitedNodes.has(nodeSetHashKey) && !sourceNodesToVisit.has(nodeSetHashKey) && grid[node] !== 'wallCell' && !targetVisitedNodes.has(nodeSetHashKey)\r\n}\r\n\r\nfunction dequeueNode(queue) {\r\n    let node = queue.shift();\r\n    let nodeId = node['nodeId'];\r\n    let parentId = node['parentId'];\r\n    return [nodeId, parentId];\r\n}\r\n","import { observable, decorate } from 'mobx';\r\nimport { createContext } from 'react';\r\nimport { runBFS } from '../libs/algorithms/bfs'\r\nimport { runDFS } from '../libs/algorithms/dfs'\r\nimport { runBiSwarm } from '../libs/algorithms/bi-swarm'\r\nimport { clearBoard } from '../libs/board';\r\n\r\nclass CellStore {\r\n    classType = 'defaultCell';\r\n    grid = {};\r\n    networkMap = {};\r\n    sourceNode = null;\r\n    targetNode = null;\r\n    selectedNode = null;\r\n    visitedNodes = null;\r\n    visitedTargetNodes = null;\r\n    animationQueue = [];\r\n    animationProperties = {\r\n        'isAnimationInProgress': false\r\n    }\r\n    row = null\r\n    col = null\r\n    activeAlgorithm = null;\r\n    getGrid = () => {\r\n        return this.grid;\r\n    };\r\n    randomNumber = (min, max) => {\r\n        return Math.floor(Math.random() * (max - min + 1) + min);\r\n    }\r\n    getRandomInt = (max) => {\r\n        return Math.floor(Math.random() * Math.floor(max));\r\n    }\r\n\r\n    clearBoard = (keepWalls) => {\r\n        clearBoard(keepWalls, this.sourceNode, this.targetNode, this.visitedNodes, this.grid);\r\n        this.visitedNodes = null;\r\n    }\r\n    runVisualizer = (enableAnimation=true) => {\r\n        switch(this.activeAlgorithm) {\r\n            case 'DFS':\r\n                this.animationProperties['isAnimationInProgress'] = true;\r\n                this.visitedNodes = runDFS(this.networkMap, this.sourceNode, this.targetNode, this.visitedNodes, this.grid, enableAnimation, this.animationProperties);\r\n                break;\r\n            case 'BFS':\r\n                this.animationProperties['isAnimationInProgress'] = true;\r\n                this.visitedNodes = runBFS(this.networkMap, this.sourceNode, this.targetNode, this.visitedNodes, this.grid, enableAnimation, this.animationProperties);\r\n                break;\r\n            case 'BiSwarm':\r\n                this.animationProperties['isAnimationInProgress'] = true;\r\n                this.visitedNodes = runBiSwarm(this.networkMap, this.sourceNode, this.targetNode, this.visitedNodes, this.visitedTargetNodes, this.grid, enableAnimation, this.animationProperties);\r\n                break;\r\n            default:\r\n                return;\r\n        }\r\n    }\r\n}\r\n\r\ndecorate( CellStore, {\r\n    grid: observable,\r\n    visitedNodes: observable\r\n});\r\n\r\nexport const CellStoreContext = createContext( new CellStore());\r\n","import React, { useContext, useState } from 'react';\r\nimport '../Cell.css';\r\nimport { CellStoreContext } from '../stores/store';\r\nimport { observer } from 'mobx-react';\r\nimport { runBFS } from '../libs/algorithms/bfs'\r\nimport { runBiSwarm } from '../libs/algorithms/bi-swarm'\r\nimport { runDFS } from '../libs/algorithms/dfs'\r\n\r\nconst Cell =  observer((props) => {\r\n    const cellStore = useContext( CellStoreContext );\r\n    const [classType, setClassType] = useState(cellStore.grid[props.id]);\r\n    const newClassType = cellStore.grid[props.id];\r\n\r\n    if (newClassType !== classType) {\r\n        setClassType(newClassType);\r\n    }\r\n\r\n    const onMouseDownHandler = () => {\r\n        if (props.id[0] === cellStore.sourceNode[0] && props.id[1] === cellStore.sourceNode[1]) {\r\n            cellStore.selectedNode = 'source';\r\n        } else if (props.id[0] === cellStore.targetNode[0] && props.id[1] === cellStore.targetNode[1]) {\r\n            cellStore.selectedNode = 'target';\r\n        } else {\r\n            cellStore.selectedNode = 'default';\r\n            if (cellStore.grid[props.id] === 'wallCell') {\r\n                cellStore.grid[props.id] = 'defaultCell';\r\n            } else {\r\n                cellStore.grid[props.id] = 'wallCell';\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    const onMouseOverHandler = () => {\r\n        if (cellStore.selectedNode && props.id.toString() !== cellStore.targetNode.toString() && props.id.toString() !== cellStore.sourceNode.toString()) {\r\n\r\n            if(cellStore.selectedNode === 'source'){\r\n                cellStore.grid[cellStore.sourceNode] = 'defaultCell';\r\n                cellStore.sourceNode = props.id;\r\n                cellStore.grid[cellStore.sourceNode] = 'startCell';\r\n            } else if (cellStore.selectedNode === 'target') {\r\n                cellStore.grid[cellStore.targetNode] = 'defaultCell';\r\n                cellStore.targetNode = props.id;\r\n                cellStore.grid[cellStore.targetNode] = 'targetCell';\r\n            } else if (cellStore.selectedNode === 'default') {\r\n                if (cellStore.grid[props.id] === 'wallCell') {\r\n                    cellStore.grid[props.id] = 'defaultCell';\r\n                } else {\r\n                    cellStore.grid[props.id] = 'wallCell';\r\n                }\r\n                cellStore.grid[props.id] = 'wallCell';\r\n            }\r\n            if(cellStore.visitedNodes){\r\n                if (cellStore.activeAlgorithm === 'BFS'){\r\n                    cellStore.visitedNodes = runBFS(cellStore.networkMap, cellStore.sourceNode, cellStore.targetNode, cellStore.visitedNodes, cellStore.grid, false)\r\n                } else if (cellStore.activeAlgorithm === 'DFS') {\r\n                    cellStore.visitedNodes = runDFS(cellStore.networkMap, cellStore.sourceNode, cellStore.targetNode, cellStore.visitedNodes, cellStore.grid, false)\r\n                } else if (cellStore.activeAlgorithm === 'BiSwarm') {\r\n                    cellStore.visitedNodes = runBiSwarm(cellStore.networkMap, cellStore.sourceNode, cellStore.targetNode, cellStore.visitedNodes, cellStore.visitedTargetNodes, cellStore.grid, false)\r\n                }\r\n            }\r\n            \r\n        }\r\n    }\r\n\r\n  return (\r\n    <div draggable='False' className={\"defaultCell \" + classType} \r\n        onMouseDown={ () => !cellStore.animationProperties['isAnimationInProgress'] && onMouseDownHandler() } \r\n        onMouseOver={ () => !cellStore.animationProperties['isAnimationInProgress'] && onMouseOverHandler() }\r\n        onMouseUp={() => cellStore.selectedNode = null}\r\n\r\n    />\r\n  );\r\n});\r\n\r\nexport default Cell;\r\n","import React, { useContext } from 'react';\r\nimport Cell from './Cell';\r\nimport { CellStoreContext } from '../stores/store';\r\n\r\nfunction Graph(props) {\r\n\r\n    const cellStore = useContext( CellStoreContext );\r\n\r\n    const createNetworkMap = (row, col) => {\r\n        const network = {};\r\n        for(let i=0; i < row; i++){\r\n            for(let j=0; j < col; j++) {\r\n                let key = [i, j];\r\n\r\n                network[key] = [];\r\n                if (j + 1 < col) {\r\n                    network[key].push([i, j + 1]);\r\n                }\r\n                \r\n                if (i + 1 < row) {\r\n                    network[key].push([i + 1, j]);\r\n                }\r\n\r\n                if (j - 1 >= 0) {\r\n                    network[key].push([i, j - 1]);\r\n                }\r\n\r\n                if (i - 1 >= 0) {\r\n                    network[key].push([i - 1, j]);\r\n                }\r\n            }\r\n        }\r\n        return network;\r\n    }\r\n\r\n    cellStore.networkMap = createNetworkMap(props.row, props.col);\r\n\r\n    const createGrid = (row, col) => {\r\n        cellStore.row = row;\r\n        cellStore.col = col;\r\n        let rowsInGrid = [];\r\n        let map = {};\r\n        for(let i=0; i < row; i++) {\r\n            let cellsInRow = [];\r\n            for(let j=0; j < col; j++) {\r\n                let cellId = [i, j];\r\n                cellsInRow.push(\r\n                    <td key={cellId} className=\"cell\">\r\n                        <Cell id={cellId} />\r\n                    </td>\r\n                );\r\n                map[cellId] = 'defaultCell';\r\n            }\r\n\r\n            rowsInGrid.push(\r\n                <tr key={i}>\r\n                    {cellsInRow}\r\n                </tr>\r\n            )\r\n            \r\n        }\r\n\r\n        cellStore.grid = map;\r\n\r\n        cellStore.sourceNode = [Math.floor(row/2) - 1, Math.floor(col/4) - 1];\r\n        cellStore.grid[cellStore.sourceNode] = 'startCell';\r\n\r\n        cellStore.targetNode = [Math.floor(row/2) - 1, Math.floor((3 * col)/4) + 1];\r\n        cellStore.grid[cellStore.targetNode] = 'targetCell';\r\n\r\n        return rowsInGrid;\r\n    }\r\n\r\n\r\n\r\n  return (\r\n    <div className=\"App\">\r\n        <table className=\"grid\" cellSpacing=\"0\" align=\"center\" \r\n        onMouseLeave={() => cellStore.selectedNode = null}\r\n        onMouseUp={() => cellStore.selectedNode = null}\r\n        >\r\n            <tbody>\r\n                {createGrid(props.row, props.col)}\r\n            </tbody>\r\n        </table>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Graph;\r\n","\r\nexport function generateMaze(row, col, sourceNode, targetNode, animationQueue, grid, animationProperties) {\r\n    animationProperties['isAnimationInProgress'] = true;\r\n    addOuterWalls(row, col, sourceNode, targetNode, animationQueue);\r\n    addInnerWalls(true, 1, col - 2, 1, row - 2, sourceNode, targetNode, animationQueue);\r\n    animateMaze(animationQueue, grid, animationProperties);\r\n}\r\n\r\nfunction animateMaze(animationQueue, grid, animationProperties) {\r\n    let shortestPathTimeoutOffset = 0;\r\n\r\n    while (animationQueue.length > 0){\r\n        let node = animationQueue.shift();\r\n        shortestPathTimeoutOffset+=10;\r\n        setTimeout(() => {  \r\n            grid[node['nodeId']] = node['value'];\r\n        }, shortestPathTimeoutOffset);\r\n    }\r\n    setTimeout(() => {  \r\n        animationProperties['isAnimationInProgress'] = false;\r\n    }, shortestPathTimeoutOffset);\r\n}\r\n\r\nfunction addOuterWalls(row, col, sourceNode, targetNode, animationQueue) {\r\n    for (let i = 0; i < row; i++) {\r\n        if (i === 0 || i === (row - 1)) {\r\n            for (let j = 0; j < col; j++) {\r\n                if ([i,j].toString() !== sourceNode.toString() && [i,j].toString() !== targetNode.toString()) {\r\n                    animationQueue.push({\r\n                        'nodeId': [i,j],\r\n                        'value': 'wallCell'\r\n                    });\r\n                }\r\n            }\r\n        } else if ([i, 0].toString() !== sourceNode.toString() && [i, 0].toString() !== targetNode.toString() && [i, col - 1].toString() !== sourceNode.toString() && [i, col - 1].toString() !== targetNode.toString()) {\r\n            animationQueue.push({\r\n                'nodeId': [i,0],\r\n                'value': 'wallCell'\r\n            });\r\n            animationQueue.push({\r\n                'nodeId': [i, col - 1],\r\n                'value': 'wallCell'\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\nfunction addInnerWalls(h, minX, maxX, minY, maxY, sourceNode, targetNode, animationQueue) {\r\n    if (h) {\r\n\r\n        if (maxX - minX < 2) {\r\n            return;\r\n        }\r\n\r\n        let y = Math.floor(randomNumber(minY, maxY)/2)*2;\r\n        addHWall(minX, maxX, y, sourceNode, targetNode, animationQueue);\r\n        addInnerWalls(!h, minX, maxX, minY, y-1, sourceNode, targetNode, animationQueue);\r\n        addInnerWalls(!h, minX, maxX, y + 1, maxY, sourceNode, targetNode, animationQueue);\r\n    } else {\r\n        if (maxY - minY < 2) {\r\n            return;\r\n        }\r\n\r\n        let x = Math.floor(randomNumber(minX, maxX)/2)*2;\r\n        addVWall(minY, maxY, x, sourceNode, targetNode, animationQueue);\r\n        addInnerWalls(!h, minX, x-1, minY, maxY, sourceNode, targetNode, animationQueue);\r\n        addInnerWalls(!h, x + 1, maxX, minY, maxY, sourceNode, targetNode, animationQueue);\r\n    }\r\n}\r\nfunction addHWall(minX, maxX, y, sourceNode, targetNode, animationQueue) {\r\n    let hole = Math.floor(randomNumber(minX, maxX)/2)*2+1;\r\n    for (let i = minX; i <= maxX; i++) {\r\n        if ([y, i].toString() !== sourceNode.toString() && [y, i].toString() !== targetNode.toString()) {\r\n            if (i === hole) {\r\n                animationQueue.push({\r\n                    'nodeId': [y,i],\r\n                    'value': 'defaultCell'\r\n                });\r\n            }\r\n            else {\r\n                animationQueue.push({\r\n                    'nodeId': [y,i],\r\n                    'value': 'wallCell'\r\n                });\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction addVWall(minY, maxY, x, sourceNode, targetNode, animationQueue) {\r\n    var hole = Math.floor(randomNumber(minY, maxY)/2)*2+1;\r\n    for (let i = minY; i <= maxY; i++) {\r\n        if ([i, x].toString() !== sourceNode.toString() && [i, x].toString() !== targetNode.toString()) {\r\n            if (i === hole) {\r\n                animationQueue.push({\r\n                    'nodeId': [i,x],\r\n                    'value': 'defaultCell'\r\n                });\r\n            }\r\n            else {\r\n                animationQueue.push({\r\n                    'nodeId': [i,x],\r\n                    'value': 'wallCell'\r\n                });\r\n            }\r\n        } \r\n    }\r\n}\r\n\r\nfunction randomNumber(min, max) {\r\n    return Math.floor(Math.random() * (max - min + 1) + min);\r\n}","import React, { useContext, useState } from 'react';\r\nimport Navbar from 'react-bootstrap/Navbar';\r\nimport Nav from 'react-bootstrap/Nav';\r\nimport NavDropdown from 'react-bootstrap/NavDropdown';\r\nimport { CellStoreContext } from '../stores/store';\r\nimport { generateMaze } from '../libs/maze'\r\n\r\nconst Header = () => {\r\n    const cellStore = useContext( CellStoreContext );\r\n    const defaultTitle = \"Select Algorithm\"\r\n    const [title, setTitle] = useState(defaultTitle);\r\n    const [visualizeTitle, setVisualizeTitle] = useState(\"Pick an Algorithm!\");\r\n  return (\r\n    <header>\r\n        <div className=\"header\">\r\n            <Navbar bg=\"dark-navy\" expand=\"lg\">\r\n                <Navbar.Brand style={{margin: '0 3vh'}} className=\"navbar-text\">Pathfinder Algorithm Visualizer</Navbar.Brand>\r\n                <Navbar.Toggle aria-controls=\"basic-navbar-nav\" className=\"navbar-text\"/>\r\n                <Navbar.Collapse id=\"basic-navbar-nav\" className=\"navbar-text\">\r\n                <Nav className=\"mr-auto\" style={{margin: '0 2vh'}}>\r\n                    <NavDropdown title={title} id=\"basic-nav-dropdown\">\r\n                        <NavDropdown.Item className=\"navbar-text\" onClick={ () => {\r\n                                cellStore.activeAlgorithm='BFS';\r\n                                setTitle(\"Breadth-first Search (BFS)\");\r\n                                setVisualizeTitle(\"Visualize Breadth-first Search (BFS)\");\r\n                            } } >Breadth-first Search (BFS)\r\n                        </NavDropdown.Item>\r\n                        <NavDropdown.Item className=\"navbar-text\" onClick={ () => {\r\n                                cellStore.activeAlgorithm='DFS';\r\n                                setTitle(\"Depth-first Search (DFS)\");\r\n                                setVisualizeTitle(\"Visualize Depth-first Search (DFS)\");\r\n                            } } >Depth-first Search (DFS)\r\n                        </NavDropdown.Item>\r\n                        <NavDropdown.Item className=\"navbar-text\" onClick={ () => {\r\n                                cellStore.activeAlgorithm='BiSwarm';\r\n                                setTitle(\"BiSwarm Search Algorithm\");\r\n                                setVisualizeTitle(\"Visualize BiSwarm Search Algorithm\");\r\n                            } } >BiSwarm Search Algorithm\r\n                        </NavDropdown.Item>\r\n                    </NavDropdown>\r\n                    <Nav.Link style={{margin: '0 2vh'}} className=\"navbar-text\" onClick={ () => !cellStore.animationProperties[\"isAnimationInProgress\"] && cellStore.clearBoard(false) } >Clear Board</Nav.Link>\r\n                    <Nav.Link style={{margin: '0 2vh'}} className=\"navbar-text\" onClick={ () => {\r\n                            if (cellStore.animationProperties[\"isAnimationInProgress\"]) return;\r\n                            cellStore.clearBoard(false); \r\n                            generateMaze(cellStore.row, cellStore.col, cellStore.sourceNode, cellStore.targetNode, cellStore.animationQueue, cellStore.grid, cellStore.animationProperties);\r\n                        } } >Create Maze</Nav.Link>\r\n                    <Nav.Link style={{margin: '0 2vh'}} className=\"navbar-text-red\" onClick={ () => !cellStore.animationProperties[\"isAnimationInProgress\"] && cellStore.runVisualizer() } >{visualizeTitle}</Nav.Link>\r\n                </Nav>\r\n                </Navbar.Collapse>\r\n            </Navbar>\r\n        </div>\r\n    </header>\r\n  );\r\n};\r\n\r\nexport default Header;\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport Graph from './components/Graph';\nimport Header from './components/Header';\nimport * as serviceWorker from './serviceWorker';\nimport './App.scss';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Header />\n    <br/>\n    <Graph row={Math.floor(window.innerHeight/30)} col={Math.floor(window.innerWidth/25)}/>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\nserviceWorker.unregister();\n"],"sourceRoot":""}